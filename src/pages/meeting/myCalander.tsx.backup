/**
 * MyScheduler Component - Calendar View for Meetings
 * 
 * Main calendar component that displays meetings in a FullCalendar interface.
 * Uses useCalendar hook for all business logic.
 * 
 * Features:
 * - Display meetings in day/week/month views
 * - Create new meetings by selecting time slots
 * - Edit existing meetings by clicking on them
 * - Delete meetings (single occurrence or entire series)
 * - Search meetings by title
 * - Context menu for quick actions
 * - Touch swipe navigation for mobile
 * - Recurring meetings with exceptions
 */

import { useEffect, useRef } from "react";
import FullCalendar from "@fullcalendar/react";
import dayGridPlugin from "@fullcalendar/daygrid";
import timeGridPlugin from "@fullcalendar/timegrid";
import interactionPlugin from "@fullcalendar/interaction";
import rrulePlugin from "@fullcalendar/rrule";
import AddMeetingModal from "./meetingModalOpen";
import ConfirmModal from "../shared/confirmDeleteModal";
import { Search } from "lucide-react";
import { useCalendar } from "./hooks";
import "./meetingStyle.css";

export default function MyScheduler() {
  // ============================================================================
  // Custom Hook - All business logic extracted
  // ============================================================================
  
  const {
    // State
    events,
    employee,
    isModalOpen,
    selectedEvent,
    isRecurrence,
    searchQuery,
    searchResults,
    contextMenu,
    deleteEvent,
    showConfirm,
    pendingEvent,
    isDeleteSeriesConfirm,
    isDeleteConfirm,
    touchStartX,
    touchEndX,
    
    // Actions
    loadMeetings,
    handleSearch,
    handleDateSelect,
    handleEventClick,
    handleEventDrop,
    handleEventResize,
    createNewMeetingAction,
    handleDeleteClick,
    deleteSingleOccurrence,
    deleteWholeSeries,
    openContextMenu,
    closeContextMenu,
    closeModal,
    checkRecurrenceChild,
    setShowConfirm,
    setIsModalOpen,
    setSelectedEvent,
    onCancelConfirm,
    setIsDeleteSeriesConfirm,
    setIsDeleteConfirm,
  } = useCalendar();
  
  // ============================================================================
  // Refs
  // ============================================================================
  
  const calendarRef = useRef<FullCalendar | null>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  const wrapperRef = useRef<HTMLDivElement>(null);
  
  // ============================================================================
  // Effect - Load Meetings on Mount
  // ============================================================================
  
  useEffect(() => {
    loadMeetings();
  }, [loadMeetings]);
  
  // ============================================================================
  // Effect - Touch Swipe Navigation for Mobile
  // ============================================================================
  
  useEffect(() => {
    const calendarEl = wrapperRef.current;
    if (!calendarEl) return;

    const handleTouchStart = (e: TouchEvent) => {
      touchStartX.current = e.touches[0].clientX;
    };

    const handleTouchMove = (e: TouchEvent) => {
      touchEndX.current = e.touches[0].clientX;
    };

    const handleTouchEnd = () => {
      const diffX = touchStartX.current - touchEndX.current;
      const threshold = 50;

      if (Math.abs(diffX) > threshold) {
        const calendar = calendarRef.current?.getApi();
        if (!calendar) return;

        if (diffX > 0) {
          calendar.next();
        } else {
          calendar.prev();
        }
      }

      touchStartX.current = 0;
      touchEndX.current = 0;
    };

    calendarEl.addEventListener('touchstart', handleTouchStart, { passive: true });
    calendarEl.addEventListener('touchmove', handleTouchMove, { passive: true });
    calendarEl.addEventListener('touchend', handleTouchEnd);

    return () => {
      calendarEl.removeEventListener('touchstart', handleTouchStart);
      calendarEl.removeEventListener('touchmove', handleTouchMove);
      calendarEl.removeEventListener('touchend', handleTouchEnd);
    };
  }, [touchStartX, touchEndX]);
  
  // ============================================================================
  // JSX - Render
  // ============================================================================
      calendarPartData: dataModal.calendarPartData
    };

    let selected: CalendarDataModal | undefined;
    if (Array.isArray(dataModal)) {
      selected = dataModal.length > 0 ? dataModal[0] : undefined;
    } else {
      selected = dataModal ?? undefined;
    }
    if (!selected) return;
    setSelectedEvent(selected);
    if (selected.calendarEventDto.type === 1) {
      setPendingEvent(true);
      setShowConfirm(true); // show the confirmation dialog
    } else {
      setIsModalOpen(true);
    }
  };

  const handleEventDrop = (dropInfo: any) => {
    setEvents(prev =>
      prev.map(e =>
        e.id === dropInfo.event.id
          ? { ...e, start: toLocalISOString(new Date(dropInfo.event.startStr)), end: toLocalISOString(new Date(dropInfo.event.endStr)) }
          : e
      )
    );
  };
  function mergeDateWithTime(baseDate: Date, timeSource: Date): Date {
    const d = new Date(baseDate);

    d.setHours(timeSource.getHours());
    d.setMinutes(timeSource.getMinutes());
    d.setSeconds(timeSource.getSeconds());
    d.setMilliseconds(0);
    return d;
  }
  function toLocalISOString(date: Date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    const h = String(date.getHours()).padStart(2, '0');
    const min = String(date.getMinutes()).padStart(2, '0');
    const s = String(date.getSeconds()).padStart(2, '0');
    return `${y}-${m}-${d}T${h}:${min}:${s}`;
  }
  const setExeptionMeetingData = async (isDeleted: boolean): Promise<CalendarDataModal | undefined> => {
    if (!selectedEvent || !clickedEventInfo) return;
    const rrule = selectedEvent.calendarEventDto.rRule!;
    // normalize clickedEventInfo to an EventApi instance (handles EventClickArg | EventApi)
    const eventApi: EventApi | null =
      ('event' in clickedEventInfo ? (clickedEventInfo as EventClickArg).event : (clickedEventInfo as EventApi)) || null;
    if (!eventApi || !eventApi.start) return;
    const clickedDateStart = new Date(eventApi.start);

    const parentStart = new Date(selectedEvent.calendarEventDto.start);
    const parentEnd = selectedEvent.calendarEventDto.end
      ? new Date(selectedEvent.calendarEventDto.end)
      : new Date(clickedDateStart.getTime() + 30 * 60 * 1000);

    const newStart = mergeDateWithTime(clickedDateStart, parentStart);
    const newEnd = mergeDateWithTime(clickedDateStart, parentEnd || parentStart);
    let indexInSeries = selectedEvent.calendarEventDto.indexInSeries !== null ?
      selectedEvent.calendarEventDto.indexInSeries :
      calculateIndexInSeries(rrule, clickedDateStart)


    let type = isDeleted ? 4 : 3
    const exceptionDto: CalendarDataModal = {
      calendarPartData: {
        ...selectedEvent.calendarPartData
      },
      calendarEventDto: {
        ...selectedEvent.calendarEventDto,
        id: 0, // new exception
        type: type,                    // ×—×¨×™×’×” ××• ××—×™×§×” ××¡×“×¨×”
        start: toLocalISOString(newStart),
        end: toLocalISOString(newEnd),
        indexInSeries: indexInSeries
      }
    };

    setSelectedEvent(exceptionDto);
    return exceptionDto;
  }
  const onCancelConfirm = () => {
    if (pendingEvent && selectedEvent && clickedEventInfo) {
      setExeptionMeetingData(false);

      setIsModalOpen(true);
    }
    setShowConfirm(false);
    // setPendingEvent(false);
  }
  const checkRrecurrenceChild = (recurrenceId?: string): boolean => {
    const hasChild = events.some(ev => ev.extendedProps.recurrenceId === recurrenceId && (ev.extendedProps.type === 3 || ev.extendedProps.type === 4));
    return hasChild;
  }
  const handleEventResize = (resizeInfo: any) => {
  setEvents(prev =>
    prev.map(e =>
      e.id === resizeInfo.event.id
        ? { 
            ...e, 
            start: toLocalISOString(new Date(resizeInfo.event.startStr)), 
            end: toLocalISOString(new Date(resizeInfo.event.endStr)) 
          }
        : e
    )
  );
};
  return (
    <div className="bg-white text-gray-600 p-2 rounded-lg shadow ">
      <h2 className="text-center text-xl font-semibold">ğŸ“… ×™×•××Ÿ ×”×¤×’×™×©×•×ª ×©×œ {employee?.name}</h2>

      {/* <div className="flex items-center justify-between mb-4">
    <div className="flex items-center gap-2">
      <button
        onClick={() => {
          calendarRef.current?.getApi().prev();
          setCurrentTitle(calendarRef.current?.getApi().view.title || "");
        }}
        className="px-3 py-1 rounded-lg bg-gray-100 hover:bg-gray-200 transition"
      >
        â†
      </button>
      <button
        onClick={() => {
          calendarRef.current?.getApi().next();
          setCurrentTitle(calendarRef.current?.getApi().view.title || "");
        }}
        className="px-3 py-1 rounded-lg bg-gray-100 hover:bg-gray-200 transition"
      >
        â†’
      </button>
      <button
        onClick={() => calendarRef.current?.getApi().today()}
        className="px-3 py-1 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition"
      >
        ×”×™×•×
      </button>
    </div>

    <div dir="rtl" className="text-center">
     
      <p className="text-gray-500 font-semibold">{currentTitle}</p> 
    </div>

    <div className="flex items-center gap-2">
      <select
        id="viewSelect"
        value={calendarView}
        onChange={(e) => handleViewChange(e.target.value as any)}
        className="border border-gray-300 rounded-lg px-3 py-1 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
      >
        <option value="timeGridDay">×™×•××™</option>
        <option value="timeGridWeek">×©×‘×•×¢×™</option>
        <option value="dayGridMonth">×—×•×“×©×™</option>
      </select>
    </div>
  </div> */}
 {/* Search bar */}
      <div className="my-4 px-2">
        <div className="relative" style={{ display: 'none' }}>
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => handleSearch(e.target.value)}
            placeholder="×—×¤×© ×¤×’×™×©×” ×œ×¤×™ ×›×•×ª×¨×ª..."
            className="w-full p-2 pl-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            dir="rtl"
          />
          {searchQuery ? (
            <button
              onClick={() => handleSearch("")}
              className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          ) : (
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" />
          )}
        </div>
        
        {/* Search results counter */}
        {searchQuery && (
          <p className="text-sm text-gray-500 mt-2">
            {searchResults.length > 0
              ? `× ××¦××• ${searchResults.length} ×¤×’×™×©×•×ª`
              : "×œ× × ××¦××• ×ª×•×¦××•×ª"}
          </p>
        )}
      </div>
    <div ref={wrapperRef}>
       <FullCalendar
      ref={calendarRef}
      timeZone="local"
      slotDuration="00:30:00"
      eventStartEditable={false}
      eventDurationEditable={false}
      direction="rtl"
      plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin, rrulePlugin]}
      initialView={"timeGridDay"}
      selectable={true}
      editable={false}
      eventDrop={handleEventDrop}
      eventResize={handleEventResize}
      select={handleDateSelect}
      eventClick={handleEventClick}
      events={events}
      
      longPressDelay={500}
      eventLongPressDelay={500}
      selectLongPressDelay={500}
      
      dragScroll={true}
      stickyHeaderDates={true}
      
      eventDidMount={(info) => {
        // Enable keyboard focus for better hover/focus styling
        info.el.tabIndex = 0;
        info.el.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          openContextMenu(e, info.event);
        });
      }}
      
      eventContent={(info) => {
        const type = info.event.extendedProps.type;
        const isRecurring = type === 1;
        const isException = type === 3;

        return (
          <div className="fc-event-custom flex items-center gap-1">
         <span>{info.event.title}</span>
         {isRecurring && !isException && <span className="recurring-symbol">ğŸ”„</span>}
         {isException && <span className="recurring-symbol">âš¡</span>}
          </div>
        );
      }}

      height="80vh"
      locale="he"
      firstDay={0}
      headerToolbar={{
        left: "prev,next today",
        center: "title",
        right: "timeGridDay,timeGridWeek,dayGridMonth",
      }}
      buttonText={{
        today: "×”×™×•×",
        month: "×—×•×“×©",
        week: "×©×‘×•×¢",
        day: "×™×•×",
      }}
      dayHeaderContent={(arg) => {
        const date = arg.date;
        const dayNames = ["×'", "×‘'", "×’'", "×“'", "×”'", "×•'", "×©'"];
        const dayName = dayNames[date.getDay()];
        const day = String(date.getDate()).padStart(2, "0");
        return `${dayName} ${day}`;
      }}
      
      handleWindowResize={true}
      windowResizeDelay={100}
       />
     </div>

      {/* Floating Add Button */}
      <button
        onClick={() => {
          createNewMeeting();
        }}
        className="fixed bottom-8 right-8 w-12 h-12 bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white rounded-full shadow-2xl flex items-center justify-center transition-all hover:scale-110 active:scale-95 z-50 group"
        title="×”×•×¡×£ ×¤×’×™×©×” ×—×“×©×”"
      >
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          className="w-6 h-6 group-hover:rotate-90 transition-transform duration-300" 
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor" 
          strokeWidth="2.5"
        >
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" />
        </svg>
      </button>

      {/* ğŸŸ¢ Modal */}
      {isModalOpen && (
        <AddMeetingModal
          isOpen={isModalOpen}
          // setIsOpen={setIsModalOpen}
          setIsOpen={() => { setIsModalOpen(false); loadMeetings(); }}
          event={selectedEvent}
          isRecurrence={isRecurrence}
          userID={employee ? employee.id : 0}
          checkRrecurrenceChild={checkRrecurrenceChild}
        />
      )}
      {isDeleteSeriesConfirm && deleteEvent && (
        <ConfirmModal
          message="×”×× ×œ××—×•×§ ××ª ×›×œ ×”×¡×“×¨×”?"
          okText="×›×Ÿ"
          cancelText="×œ×"
          onOk={async () => {
            deleteWholeSeries(deleteEvent);
            setIsDeleteSeriesConfirm(false);
            loadMeetings();
          }}
          onCancel={async () => {
            // â† ×–×” ××—×™×§×” ×¨×§ ×©×œ occurrence ×™×—×™×“
            await deleteSingleOccurrence(deleteEvent);
            setIsDeleteSeriesConfirm(false);
            loadMeetings();
          }}
        />
      )}
      {isDeleteConfirm && deleteEvent && (
        <ConfirmModal
          message="×”×× ×œ××—×•×§ ××ª ×”×¤×’×™×©×”?"
          okText="×›×Ÿ"
          cancelText="×œ×"
          onOk={async () => {
            await deleteSingleOccurrence(deleteEvent);
            setIsDeleteConfirm(false);
            loadMeetings();
          }}
          onCancel={() => setIsDeleteConfirm(false)}
        />
      )}
      {showConfirm && (
        <ConfirmModal
          okText="×›×Ÿ"
          cancelText="×œ×"
          message="×”×× ×œ×¤×ª×•×— ××ª ×›×œ ×”×¡×“×¨×”?"
          onOk={() => {
            if (pendingEvent) {
              setSelectedEvent(prev =>
                prev
                  ? {
                    ...prev,
                    calendarEventDto: { ...prev.calendarEventDto, type: 1 },
                  }
                  : prev
              );
              setIsModalOpen(true);
            }
            setShowConfirm(false);
          }}
          onCancel={() => {
            onCancelConfirm();
          }}
        />)}
      {contextMenu.event && (
        <div
          style={{
            position: "fixed",
            top: contextMenu.y,
            left: contextMenu.x,
            background: "white",
            border: "1px solid #ccc",
            padding: "5px 10px",
            borderRadius: "5px",
            zIndex: 9999,
            cursor: "pointer",
          }}
          onMouseLeave={closeContextMenu}
        >
          <div
            onClick={() => handleDeleteClick(contextMenu.event!)}
            style={{ padding: "5px" }}
          >
            ××—×§
          </div>
        </div>
      )}
      <style>
        {`
          .fc .fc-event,
          .fc .fc-event-main {
            transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
          }
          .fc .fc-event:hover,
          .fc .fc-event:focus,
          .fc .fc-event:focus-visible {
            filter: brightness(1.08);
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18);
            z-index: 10 !important;
          }
          .fc .fc-event:focus-visible {
            outline: 2px solid #2563eb;
            outline-offset: 2px;
          }
        `}
      </style>
    </div>
  );
}
